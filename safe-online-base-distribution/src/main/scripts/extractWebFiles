#!/bin/bash
# ___________________________________________________________________________ #
#                                                                             #
#       ExtractWebFiles -- Extract JBoss web files to allow live editing and  #
#                          later apply them onto the source repository.       #
#                                                                             #
#                                                                             #
#    Licensed under the Apache License, Version 2.0 (the "License");          #
#    you may not use this file except in compliance with the License.         #
#    You may obtain a copy of the License at                                  #
#                                                                             #
#        http://www.apache.org/licenses/LICENSE-2.0                           #
#                                                                             #
#    Unless required by applicable law or agreed to in writing, software      #
#    distributed under the License is distributed on an "AS IS" BASIS,        #
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
#    See the License for the specific language governing permissions and      #
#    limitations under the License.                                           #
# ___________________________________________________________________________ #
#                                                                             #
#                                                                             #
# Copyright 2007, lhunath                                                     #
#   * http://lhunath.lyndir.com                                               #
#   * Maarten Billemont.                                                      #
#                                                                             #
source "${0%/*}/bashlib"                                                      #
scripts="${0%/*}"; [[ $scripts = /* ]] || scripts=$PWD/$scripts
distribution=$(cd "$scripts/.."; echo "${PWD##*/}")
source "$scripts/bashlib"
shopt -s nullglob

# Parse options.
for arg in $(getArgs hdLRavf "$@"); do
    case $arg in
		h) showHelp \
			'Extract Web Files' \
            "Extract Web Application source files (HTML/CSS) for easy runtime editing.
             Can also apply their changes onto your source repository." \
			'lhunath' \
			\
            '-L' "Don't hard-link the JBoss files to the work directory; make copies instead." \
            '-R' "Reverse operation.  Instead of pulling files out of JBoss, apply the work dir onto the running JBoss deployment." \
			'-a' "Apply work dir changes onto your source repository." \
			'-v' "Verbose mode.  Give some more detail about non-trivial operations." \
            '-d' "Debug mode; explain as much as possible about what's being done." \
            '-f' "Forceful operation.  Overwrite your repository files with those from the work dir when applying, even when your
                  files are of a newer version than the original work dir files."

			exit		;;
        L) nolink=1     ;;
        R) reverse=1    ;;
        a) apply=1      ;;
        v) verbose=1    ;;
        d) debug=1
           verbose=1    ;;
        f) force=1      ;;
    esac
done
(( verbose + debug )) || quiet=1


# Parse distribution and base paths.
base="$scripts/.."
work="$base/work"
pwd=$PWD


# Figure out which webapps to use.
[[ -d "$base/jboss/server/default/deploy" ]] \
    && webapps=( "$base/jboss/server/default/deploy/"{SafeOnline*,Dodentocht*}.ear ) \
    || webapps=( "$work/"* )
webapps=( "${webapps[@]%.ear}" )
webapps=( "${webapps[@]##*/}" )
if (( apply )); then
    repos=()
    for webapp in "${webapps[@]}"; do
        source=( "$base"/../*/*/target/"$webapp.ear" )
        if (( ${#source[@]} )); then
            source=( "${source[@]%/*/target/*}" )
        else
            source=$(ask "Source repository to apply $webapp onto:")
        fi

        [[ -d $source ]] && repos+=("$source")
    done
    (( ${#repos[@]} != ${#webapps[@]} )) && {
        emit -R "Not an equal amount of repositories (${#repos[@]}) and web applications (${#webapps[@]})."
        exit 1
    }
fi


# Make sure distribution is deployed and files are available for extraction.
(( ! apply )) && {
    tmp=(  )
    [[ -d "$base/jboss/server/default/tmp" ]] || {
        emit -r "Invalid distribution path or distribution not deployed: $distribution at $base"
        exit 1
    }
}


# Some debug info.
(( debug )) && (
    IFS=,
    emit "Base    : $(shorten "$base")"
    emit "Pwd     : $(shorten "$pwd")"
    emit "webapps : ${webapps[*]}"
    emit "repos   : ${repos[*]}"
)


# Extraction work functions.
function extractCss {
    css=( *'/css/style.css' )
    [[ -e $css ]]                                   || return 0

    mkdir -p "$work/$webapp/css"                    || return
    (( reverse )) || {
        mv "$css" "$work/$webapp/css/" && \
        cp "$work/$webapp/css/${css##*/}"{,~}       || return
    }

    for file in "${css[@]}"; do
        if (( nolink )); then
            cp -f "$work/$webapp/css/style.css" "$file"
        else
            ln -f "$work/$webapp/css/style.css" "$file"
        fi

        (( ! $? )) && touch "$file"                 || return
    done
}
function extractHtml {
    while read file; do
        mkdir -p "$work/$webapp/${file%/*}"         || return
        (( reverse )) || {
            mv "$file" "$work/$webapp/$file" && \
            cp "$work/$webapp/$file"{,~}            || return
        }

        [[ -e "$work/$webapp/$file" ]] && {
            if (( nolink )); then
                cp -f "$work/$webapp/$file" "$file"
            else
                ln -f "$work/$webapp/$file" "$file"
            fi

            (( ! $? )) || return
        }

        touch "$file"                               || return
    done < <(find . -name '*.xhtml' -o -name '*.html')
}
function extractStuff {

        extractCss && \
        extractHtml
}


# Figure out what to do now.
if (( apply )); then
    [[ ! -e $work ]] && {
        emit -R "No work files present at $(shorten "$work").  Cannot apply."
        exit 1
    }
elif (( ! reverse )); then
    [[ -e $work ]] && {
        emit -Y "You already have work files at $(shorten "$work").  Perhaps you meant to use -R?"
        emit -Y "Continuing will delete all these files and replace them by the current server's files."
        echo; ask -y!N "Continue?" || exit

        emit "Cleaning up $(shorten "$work")" --
            rm -rf "$work"
        emit -$?
    }
fi

if (( reverse )); then
    emit "Linking web files from $(shorten "$work") to $(shorten "$base")" ${quiet:+--}
elif (( apply )); then
    emit "Applying web files from $(shorten "$work") to repository" ${quiet:+--}
else
    emit "Linking web files from $(shorten "$base") to $(shorten "$work")" ${quiet:+--}
fi

if (( apply )); then
    for w in "${!webapps[@]}"; do
        webapp=${webapps[w]}
        cd "$work/$webapp"

        (( debug )) && \
            emit -G "Working on $webapp($w) at $PWD"

        find . '(' -name '*.html' -o -name '*.xhtml' -o -name '*.css' ')' -print0 | while read -d '' file; do
            [[ -e $file~ ]] || {
                emit -y "Backup of $(shorten -p "$pwd" "$file") not found."
                continue
            }

            fileHash=$(openssl md4 < "$file")
            backHash=$(openssl md4 < "$file~")

            (( debug )) && \
                emit " - Hashes of $(shorten "$file"): current: $fileHash <-> backup: $backHash${force:+ (forcing)}"

            if (( force )) || [[ $fileHash != $backHash ]]; then
                ddest="${repos[w]}/${file/-?.*-exp.war//src/main/webapp}"
                ddest=${ddest//webapp\/WEB-INF\/classes/java}
                destHash=$([[ -e $ddest ]] && openssl md4 < "$ddest")

                (( debug )) && \
                    emit " - - First Destination candidate: $(shorten "$ddest") (hash: ${destHash:-${red}doesn\'t exist$reset})"

                if [[ $destHash = $fileHash ]]; then
                    emit "   - $(shorten -p "$pwd" "$ddest"): ${bold}${green}up to date${reset}."
                    continue

                elif [[ ! -e $ddest ]] || [[ $destHash != $backHash ]]; then
                    adest=( "${repos[w]}/"*"/src/main/webapp/${file/*-1.2-SNAPSHOT-exp.war/}" )

                    (( debug )) && \
                        emit " - - Additional Candidates:"

                    for ad in ${!adest[@]}; do
                        for exclude in $excludes; do
                            [[ ${adest[ad]} = *$exclude* ]] && {
                                (( debug )) && \
                                    emit " - - - $ad: $(shorten "${adest[ad]}") matches *$exclude* -> excluded."
                                
                                unset adest[ad]
                            }
                        done
                    done
                    adest=("${adest[@]}")
                    uptodate=
                    mdest=()

                    for dest in "${adest[@]}"; do
                        destHash=$(openssl md4 < "$dest")

                        if [[ $destHash = $backHash ]]; then
                            mdest+=( "$dest" )

                            (( debug )) && \
                                emit " - - - $(shorten "$dest"): $destHash: Eligable."
                        elif [[ $destHash = $fileHash ]]; then
                            uptodate=1; mdest=$dest

                            (( debug )) && \
                                emit " - - - $(shorten "$dest"): $destHash: Already applied; skipping to next file."

                            break
                        else
                            (( debug )) && \
                                emit " - - - $(shorten "$dest"): $destHash: Discarted."
                        fi
                    done

                    if [[ ! $uptodate && ( ! ${#mdest[@]} || ${#mdest[@]} > 1 || ! -e $mdest ) ]]; then
                        emit -y "Source of $(shorten -p "$pwd" "$file") could not be determined.  Possibilities:"
                        for dest in "$ddest" "${adest[@]}"; do
                            hash=$([[ -e $dest ]] && openssl md4 < "$dest")
                            emit -y "   - $(shorten -p "$pwd" "$dest"):"\
                                    "$([[ -e $dest ]] && echo "${green}exists${reset}" || echo "${red}doesn't exist${reset}"),"\
                                    "$([[ $hash = $backHash ]] && echo "${green}match${reset}" || echo "${red}no match${reset}")"\
                                    "$([[ -r $dest && $fileHash = $hash ]] && echo "(${bold}${green}up to date${reset})")"
                        done

                        continue
                    fi

                    dest=$mdest

                else
                    dest=$ddest

                fi

                (( verbose )) \
                    && emit "Updating ${file%%*/}:"
                if [[ $fileHash != $(openssl md4 < "$dest") ]]; then
                    emit "   - $(shorten -p "$pwd" "$file") => $(shorten -p "$pwd" "$dest" "/${file##*/}")" --
                        mv "$dest"{,~} && cp "$file" "$dest"
                    emit -$?
                else
                    emit "   - $(shorten -p "$pwd" "$dest"): ${bold}${green}up to date${reset}."
                fi
            fi
        done
    done
else
    for webapp in "${webapps[@]}"; do
        loc=( "$base"/jboss/server/default/tmp/deploy/*"$webapp.ear-contents"/*/META-INF/../.. )
        (( ${#loc[@]} )) && cd "$loc" && \
            extractStuff
    done
fi

(( quiet )) && emit -$?
