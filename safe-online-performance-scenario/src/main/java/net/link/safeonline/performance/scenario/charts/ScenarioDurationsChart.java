/*
 *   Copyright 2008, Maarten Billemont
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
package net.link.safeonline.performance.scenario.charts;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.FilterChain;

import net.link.safeonline.performance.entity.DriverProfileEntity;
import net.link.safeonline.performance.entity.ProfileDataEntity;
import net.link.safeonline.performance.entity.ScenarioTimingEntity;
import net.link.safeonline.util.filter.ProfileFilter;
import net.link.safeonline.util.performance.ProfileData;

import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.StackedXYBarRenderer;
import org.jfree.data.xy.DefaultTableXYDataset;
import org.jfree.data.xy.XYSeries;


/**
 * <h2>{@link ScenarioDurationsChart}<br>
 * <sub>A chart module that renders a driver durations and agent overhead.</sub></h2>
 *
 * <p>
 * The chart generated by this module is a stacked area chart stacking the request time of each driver used in the
 * scenario below the agent overhead time.<br>
 * <br>
 * Request time is defined as the time spent on the OLAS server during the {@link ProfileFilter}'s
 * {@link FilterChain#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)} call. This basically
 * involves all capturable time spent on the OLAS Application Server for each web request made to it.<br>
 * <br>
 * Agent Overhead is defined as the time spent executing a scenario as recorded by the agent minus the cumulative driver
 * request times. This basically involves remote request latency and latency introduced by agent operations such as
 * gathering and persisting of statistical data.
 * </p>
 *
 * <p>
 * <i>Feb 22, 2008</i>
 * </p>
 *
 * @author mbillemo
 */
public class ScenarioDurationsChart extends AbstractChart {

    private Map<String, XYSeries> driverSets;
    private XYSeries              overhead;


    /**
     * Create a new {@link ScenarioDurationsChart} instance.
     */
    public ScenarioDurationsChart() {

        super("Scenario Duration");

        this.driverSets = new HashMap<String, XYSeries>();
        this.overhead = new XYSeries("Agent Overhead", true, false);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void processTiming(ScenarioTimingEntity data) {

        if (data.getAgentDuration() != null && data.getOlasDuration() != null) {
            this.overhead.addOrUpdate(data.getStart(), data.getAgentDuration() - data.getOlasDuration());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isTimingProcessed() {

        return true;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void processData(ProfileDataEntity data) {

        if (data.getMeasurements().isEmpty())
            return;

        XYSeries driverSet = getDriverSet(data.getProfile());

        Long startTime = data.getScenarioTiming().getStart();
        Long requestTime = getMeasurement(data.getMeasurements(), ProfileData.REQUEST_DELTA_TIME);

        driverSet.addOrUpdate(startTime, requestTime);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isDataProcessed() {

        return true;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected XYPlot getPlot() {

        if (isEmpty(this.driverSets))
            return null;

        ValueAxis domainAxis = new DateAxis("Time");
        NumberAxis valueAxis = new NumberAxis("Duration (ms)");

        DefaultTableXYDataset scenarioDuration = new DefaultTableXYDataset();
        for (XYSeries driverSet : this.driverSets.values()) {
            scenarioDuration.addSeries(driverSet);
        }
        scenarioDuration.addSeries(this.overhead);

        return new XYPlot(scenarioDuration, domainAxis, valueAxis, new StackedXYBarRenderer());
    }

    private XYSeries getDriverSet(DriverProfileEntity profile) {

        String driverName = profile.getDriverClassName().replaceFirst(".*\\.", "");
        XYSeries driverSet = this.driverSets.get(driverName);

        if (driverSet == null) {
            this.driverSets.put(driverName, driverSet = new XYSeries(driverName, true, false));
        }

        return driverSet;
    }
}
